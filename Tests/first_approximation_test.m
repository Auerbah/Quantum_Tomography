% Программа для восстановления состояния, заданого матрицей плотности
% Возможно восстановление как чистого, так и смешанного состояния
clc
clear
close all
addpath('../../Protocols');
addpath('../');
rng(1,'twister');

%% Начальные условия
S = 1;             % Число кубитов S = 1 - один кубит
n_exp = 1000;      % Число экспериментов
n = 1000;          % Выборка в каждом эксперименте
a = 0.5;           % Параметр сходимости
x = X_Octahedron; % Выбранный протокол

%% Ортогональные состояния, на основе которых строится матрица плотности
psi0 = [1; 0];
psi1 = [0; 1];

phi0 = 1 / sqrt(2) * [1; 1];
phi1 = 1 / sqrt(2) * [1; -1];

chi0 = 1 / sqrt(2) * [1; 1i];
chi1 = 1 / sqrt(2) * [1; -1i];

%% Выбранное состояние
% p = 0.5;
% po = create_po_matrix(psi0,chi0,p,1); % Матрица плотности
% po = kron_S(po,S);
po = chi0'*chi0
x = kron_S(x, S);

[m, s] = size(x) % m - число строк в аппаратной матрице
                 % s - размерность системы
                 
%% Задание времени экспозиции для измерения в каждом базисе
t = time_for_protocol(n, s, m, 'uniform');
                 
%% Восстановление с рангом r = 1
% Если присутсвует смесь с маленьким весом,
% то ранг нужно переопределить
r = rank(po)

%% Расчет вероятности регистрации событий {r = 1}
lambda = lambda_for_protocol(x, m, po);

%% Новая аппаратная матрица {r = 1}
X = X_for_mixed(r, x);

%% Новые проекторы {r = 1}
Lambda = Lambda_for_mixed(X);

%% Матрица I {r = 1}
I = I_for_protocol(Lambda, r, s, t, m);

%% Генерация числа фотонов, подчиняющихся распределению Пуассона
K = generate_K(lambda, t);

%%

C = first_approximation( X, t, K, r )

